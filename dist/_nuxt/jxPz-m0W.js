import{g as z,r as P,H as $,I as W,c as O,a as u,t as w,k as y,J as L,d as x,p as H,b as G,w as J,T as Q,C as q,o as N,D as V,K,L as p,M as X,i as Z,N as k,O as M,P as A,Q as ee,R as ae,S as te,U as se,V as ne}from"./WFAcvMe-.js";import{_ as re}from"./DlAUqK2U.js";const le=window.setInterval,ie={class:"timer-inner"},ue={class:"status-badge"},ce={class:"round-display"},oe={class:"value"},de={class:"time-display-wrapper"},fe={class:"progress-ring",viewBox:"0 0 100 100"},ve={class:"time-main"},_e={key:0,class:"up-arrow"},me={class:"timer-settings"},De={class:"setting-item"},ye={class:"controls"},he={class:"setting-item"},ge={class:"controls"},be={class:"action-grid"},Re=["disabled"],Te={key:0,class:"toast-popup"},Ce=z({__name:"WorkoutTimer",props:{defaultRestTime:{},defaultWorkTime:{},currentSet:{},totalSets:{}},setup(e){const a=e,n=P("READY"),r=P(0),t=P(!1),l=P(null),s=P(a.defaultRestTime||60),o=P(a.defaultWorkTime||0),d=P(a.currentSet||1),h=P(""),i=V(()=>n.value==="WORK"?o.value:s.value),C=V(()=>n.value==="READY"||n.value==="FINISH"||i.value===0?0:n.value==="WORK"&&o.value===0?100:r.value/i.value*100),g=D=>{const f=Math.floor(D/60),E=D%60;return`${f}:${E.toString().padStart(2,"0")}`},R=D=>{h.value=D,setTimeout(()=>{h.value=""},3e3)},c=(D,f=[200,100,200])=>{R(D),navigator.vibrate&&navigator.vibrate(f)},_=()=>{t.value||(n.value==="READY"&&(n.value="WORK",r.value=o.value>0?o.value:0),n.value==="FINISH"&&(n.value="READY",d.value=1,r.value=0),t.value=!0,l.value=le(()=>{n.value==="WORK"?o.value>0?r.value>0?r.value--:S():r.value++:n.value==="REST"&&(r.value>0?r.value--:b())},1e3))},S=()=>{c(`${d.value}セット目完了！休憩を開始します。`,[300,100,300]),n.value="REST",r.value=s.value},b=()=>{d.value<(a.totalSets||99)?(d.value++,c(`${d.value}セット目開始！`,[500]),n.value="WORK",r.value=o.value):(n.value="FINISH",T(),c("全セット完了！お疲れ様でした！",[200,100,200,100,500]))},T=()=>{t.value=!1,l.value&&clearInterval(l.value)},v=()=>{T(),n.value="READY",r.value=0,d.value=a.currentSet||1},m=()=>{n.value==="WORK"?S():n.value==="REST"&&b()};return $(()=>{l.value&&clearInterval(l.value)}),W(()=>a.currentSet,D=>{D&&n.value==="READY"&&(d.value=D)}),W(()=>a.defaultRestTime,D=>{D&&(s.value=D)}),W(()=>a.defaultWorkTime,D=>{D&&(o.value=D)}),(D,f)=>(N(),O("div",{class:q(["timer-card",y(n).toLowerCase()])},[u("div",ie,[u("div",ue,w(y(n)),1),u("div",ce,[f[4]||(f[4]=u("span",{class:"label"},"ROUND",-1)),u("span",oe,w(y(d))+" / "+w(e.totalSets||"-"),1)]),u("div",de,[(N(),O("svg",fe,[f[5]||(f[5]=u("circle",{class:"progress-ring-track",cx:"50",cy:"50",r:"45"},null,-1)),u("circle",{class:"progress-ring-fill",cx:"50",cy:"50",r:"45",style:L({strokeDashoffset:283-283*y(C)/100})},null,4)])),u("div",ve,[x(w(g(y(r)))+" ",1),y(n)==="WORK"&&y(o)===0?(N(),O("span",_e,"▲")):H("",!0)])]),u("div",me,[u("div",De,[f[6]||(f[6]=u("label",null,"Work",-1)),u("div",ye,[u("button",{onClick:f[0]||(f[0]=E=>o.value=Math.max(0,y(o)-5))},"-"),u("span",null,w(y(o))+"s",1),u("button",{onClick:f[1]||(f[1]=E=>o.value+=5)},"+")])]),u("div",he,[f[7]||(f[7]=u("label",null,"Rest",-1)),u("div",ge,[u("button",{onClick:f[2]||(f[2]=E=>s.value=Math.max(0,y(s)-5))},"-"),u("span",null,w(y(s))+"s",1),u("button",{onClick:f[3]||(f[3]=E=>s.value+=5)},"+")])])]),u("div",be,[y(t)?(N(),O("button",{key:1,onClick:T,class:"btn btn-danger"},"STOP")):(N(),O("button",{key:0,onClick:_,class:"btn btn-primary"},"START")),u("button",{onClick:m,class:"btn btn-secondary",disabled:y(n)==="FINISH"||y(n)==="READY"},"SKIP",8,Re),u("button",{onClick:v,class:"btn btn-outline"},"RESET")])]),G(Q,{name:"toast"},{default:J(()=>[y(h)?(N(),O("div",Te,w(y(h)),1)):H("",!0)]),_:1})],2))}}),Be=re(Ce,[["__scopeId","data-v-cbe621f3"]]),Se={trailing:!0};function Pe(e,a=25,n={}){if(n={...Se,...n},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let r,t,l=[],s,o;const d=(h,i)=>(s=pe(e,h,i),s.finally(()=>{if(s=null,n.trailing&&o&&!t){const C=d(h,o);return o=null,C}}),s);return function(...h){return s?(n.trailing&&(o=h),s):new Promise(i=>{const C=!t&&n.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const g=n.leading?r:d(this,h);for(const R of l)R(g);l=[]},a),C?(r=d(this,h),i(r)):l.push(i)})}}async function pe(e,a,n){return await e.apply(a,n)}const Ee=Symbol.for("nuxt:client-only"),we=e=>e==="defer"||e===!1;function Me(...e){var R;const a=typeof e[e.length-1]=="string"?e.pop():void 0;Oe(e[0],e[1])&&e.unshift(a);let[n,r,t={}]=e;const l=V(()=>ne(n));if(typeof l.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof r!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const s=K();t.server??(t.server=!0),t.default??(t.default=Ie),t.getCachedData??(t.getCachedData=j),t.lazy??(t.lazy=!1),t.immediate??(t.immediate=!0),t.deep??(t.deep=p.deep),t.dedupe??(t.dedupe="cancel"),t._functionName,s._asyncData[l.value];const o={cause:"initial",dedupe:t.dedupe};(R=s._asyncData[l.value])!=null&&R._init||(o.cachedData=t.getCachedData(l.value,s,{cause:"initial"}),s._asyncData[l.value]=F(s,l.value,r,t,o.cachedData));const d=s._asyncData[l.value];d._deps++;const h=()=>s._asyncData[l.value].execute(o),i=t.server!==!1&&s.payload.serverRendered;{let c=function(v){const m=s._asyncData[v];m!=null&&m._deps&&(m._deps--,m._deps===0&&(m==null||m._off()))};const _=te();if(_&&i&&t.immediate&&!_.sp&&(_.sp=[]),_&&!_._nuxtOnBeforeMountCbs){_._nuxtOnBeforeMountCbs=[];const v=_._nuxtOnBeforeMountCbs;X(()=>{v.forEach(m=>{m()}),v.splice(0,v.length)}),$(()=>v.splice(0,v.length))}const S=_&&(_._nuxtClientOnly||Z(Ee,!1));i&&s.isHydrating&&(d.error.value||d.data.value!=null)?(d.pending.value=!1,d.status.value=d.error.value?"error":"success"):_&&(!S&&s.payload.serverRendered&&s.isHydrating||t.lazy)&&t.immediate?_._nuxtOnBeforeMountCbs.push(h):t.immediate&&h();const b=se(),T=W([l,...t.watch||[]],([v],[m])=>{var D,f;if((v||m)&&v!==m){const E=((D=s._asyncData[m])==null?void 0:D.data.value)!==p.value,U=s._asyncDataPromises[m]!==void 0;m&&c(m);const B={cause:"initial",dedupe:t.dedupe};(f=s._asyncData[v])!=null&&f._init||(B.cachedData=t.getCachedData(v,s,{cause:"initial"}),s._asyncData[v]=F(s,v,r,t,B.cachedData)),s._asyncData[v]._deps++,(t.immediate||E||U)&&s._asyncData[v].execute(B)}else d._execute({cause:"watch",dedupe:t.dedupe})},{flush:"sync"});b&&k(()=>{T(),c(l.value)})}const C={data:I(()=>{var c;return(c=s._asyncData[l.value])==null?void 0:c.data}),pending:I(()=>{var c;return(c=s._asyncData[l.value])==null?void 0:c.pending}),status:I(()=>{var c;return(c=s._asyncData[l.value])==null?void 0:c.status}),error:I(()=>{var c;return(c=s._asyncData[l.value])==null?void 0:c.error}),refresh:(...c)=>s._asyncData[l.value].execute(...c),execute:(...c)=>s._asyncData[l.value].execute(...c),clear:()=>Y(s,l.value)},g=Promise.resolve(s._asyncDataPromises[l.value]).then(()=>C);return Object.assign(g,C),g}function I(e){return V({get(){var a;return(a=e())==null?void 0:a.value},set(a){const n=e();n&&(n.value=a)}})}function Oe(e,a){return!(typeof e=="string"||typeof e=="object"&&e!==null||typeof e=="function"&&typeof a=="function")}function Y(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=p.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=p.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}function Ne(e,a){const n={};for(const r of a)n[r]=e[r];return n}function F(e,a,n,r,t){var C;(C=e.payload._errors)[a]??(C[a]=p.errorValue);const l=r.getCachedData!==j,s=n,o=r.deep?P:M,d=t!=null,h=e.hook("app:data:refresh",async g=>{(!g||g.includes(a))&&await i.execute({cause:"refresh:hook"})}),i={data:o(d?t:r.default()),pending:M(!d),error:ae(e.payload._errors,a),status:M("idle"),execute:(...g)=>{const[R,c=void 0]=g,_=R&&c===void 0&&typeof R=="object"?R:{};if(e._asyncDataPromises[a]){if(we(_.dedupe??r.dedupe))return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if(_.cause==="initial"||e.isHydrating){const b="cachedData"in _?_.cachedData:r.getCachedData(a,e,{cause:_.cause??"refresh:manual"});if(b!=null)return e.payload.data[a]=i.data.value=b,i.error.value=p.errorValue,i.status.value="success",Promise.resolve(b)}i.pending.value=!0,i.status.value="pending";const S=new Promise((b,T)=>{try{b(s(e))}catch(v){T(v)}}).then(async b=>{if(S.cancelled)return e._asyncDataPromises[a];let T=b;r.transform&&(T=await r.transform(b)),r.pick&&(T=Ne(T,r.pick)),e.payload.data[a]=T,i.data.value=T,i.error.value=p.errorValue,i.status.value="success"}).catch(b=>{if(S.cancelled)return e._asyncDataPromises[a];i.error.value=ee(b),i.data.value=y(r.default()),i.status.value="error"}).finally(()=>{S.cancelled||(i.pending.value=!1,delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=S,e._asyncDataPromises[a]},_execute:Pe((...g)=>i.execute(...g),0,{leading:!0}),_default:r.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{var g;h(),(g=e._asyncData[a])!=null&&g._init&&(e._asyncData[a]._init=!1),l||A(()=>{var R;(R=e._asyncData[a])!=null&&R._init||(Y(e,a),i.execute=()=>Promise.resolve(),i.data.value=p.value)})}};return i}const Ie=()=>p.value,j=(e,a,n)=>{if(a.isHydrating)return a.payload.data[e];if(n.cause!=="refresh:manual"&&n.cause!=="refresh:hook")return a.static.data[e]};export{Be as _,Me as u};
